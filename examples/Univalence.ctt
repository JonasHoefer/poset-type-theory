module Univalence where

import Prelude
import Paths


-- https://github.com/mortberg/cubicaltt/blob/master/examples/univalence.ctt

--------------------------------------------------------------------------------
---- basics

const (A B : U) (b : B) (_ : A) : B = b


--------------------------------------------------------------------------------
---- HoTT basics

Homotopy (A B : U) (f g : A -> B) : U = (x : A) -> Path B (f x) (g x)

hasRetract (A B : U) (s : A -> B) : U = (r : B -> A) * Homotopy A A (\x. r (s x)) (id A)

Retraction (A B : U) : U = (s : A -> B) * hasRetract A B s

RetractionInd (A B : U) (P : A -> U) (ret : Retraction A B) (p : (y : B) -> P (ret.2.1 y)) (x : A) : P x
  = tr A P (ret.2.1 (ret.1 x)) x (ret.2.2 x) (p (ret.1 x))


--------------------------------------------------------------------------------
---- HLevel

isContrFam (A : U) (B : A -> U) : U = (x : A) -> isContr (B x)

retractIsContr (A B : U) (ret : Retraction A B) (isCntrB : isContr B) : isContr A
  = let cB : B = isCntrB.1
	CB : Homotopy B B (const B B cB) (id B) = isCntrB.2
        cA : A = ret.2.1 cB
    in  (cA, RetractionInd A B (\a. Path A cA a) ret (\b. ap B A ret.2.1 cB b (CB b)))

-- isContrSigma (A : U) (B : A -> U) (isCntrA : isContr A) (isCntrB : isContrFam A B) : isContr ((x : A) * B x)
--   =



--------------------------------------------------------------------------------

Equiv (A B : U) : U = (f : A -> B) * isEquiv A B f

IdEquiv (A : U) : Equiv A A = (id A , isEquivId A)

EquivToPath (A B : U) (e : Equiv A B) : Path U A B
  = \i. Ext B [ (i=0) -> (A, e.1, e.2) , (i=1) -> (B, id B, isEquivId B) ]
