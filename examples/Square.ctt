module Square where


Square (A : U) (a0 a1 b0 b1 : A)
               (u : Path A a0 a1) (v : Path A b0 b1)
               (r0 : Path A a0 b0) (r1 : Path A a1 b1) : U
  = PathP (i. (PathP (j.A) (u i) (v i))) r0 r1



constSquare (A : U) (a : A) (p : Path A a a) : Square A a a a a p p p p =
  \i j. hComp 0 1 A (p (i \/ j))
             [ (i = 0) -> k. p j
             , (i = 1) -> k. p (j /\ k)
             , (j = 0) -> k. p i
             , (j = 1) -> k. p (i /\ k) ]

data S1 : U = base | loopAt <i>  [ (i=0) -> base, (i=1) -> base ]

mLoop : (x : S1) -> Path S1 x x = split
  base -> \i. loopAt i
  loopAt i -> constSquare S1 base (\ j. loopAt j) i


mult (x : S1) : S1 -> S1 = split
  base -> x
  loopAt i -> mLoop x i

test : S1 = mult base base




{-




 Square (A : U) (a0 a1 b0 b1 : A)
               (u : Path A a0 a1) (v : Path A b0 b1)
               (r0 : Path A a0 b0) (r1 : Path A a1 b1) : U
  = PathP (<i> (PathP (<j> A) (u @ i) (v @ i))) r0 r1

constSquare (A : U) (a : A) (p : Path A a a) : Square A a a a a p p p p =
  <i j> comp (<_> A) a
             [ (i = 0) -> <k> p @ j \/ - k
             , (i = 1) -> <k> p @ j /\ k
             , (j = 0) -> <k> p @ i \/ - k
             , (j = 1) -> <k> p @ i /\ k ]
-}